import numpy as np
import cv2
import os
import torch
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.sparse.csgraph import dijkstra
from scipy.sparse import csr_matrix
import matplotlib.image as mpimg
import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog
import heapq
from matplotlib.path import Path
import matplotlib.patches as patches


plt.rcParams["font.family"] = ["SimHei"]
os.environ['KMP_DUPLICATE_LIB_OK'] = 'True'
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")


def ensure_gray(image):
    if image is None:
        return None
    if len(image.shape) == 3:
        return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    return image


def show_map_with_annotations(img_path):
    img = mpimg.imread(img_path)
    fig, ax = plt.subplots(figsize=(12, 8))
    ax.imshow(img, origin='upper')
    ax.set_title("点击地图选择垃圾桶位置（按Enter键结束）")
    ax.set_aspect('equal')

    bin_positions = []
    fill_rates = []
    annotations = []

    def onclick(event):
        if event.inaxes == ax and event.button == 1:
            x, y = event.xdata, event.ydata
            if x is None or y is None: return

            bin_positions.append((x, y))
            point = ax.plot(x, y, 'ro', markersize=10)[0]

            fill_rate = simpledialog.askfloat(
                "填充率输入",
                f"请输入垃圾桶 {len(bin_positions)} 的填充率（0-100%）",
                minvalue=0, maxvalue=100
            )
            if fill_rate is not None:
                fill_rates.append(fill_rate / 100)
                annotation = ax.text(
                    x, y + 15,
                    f"{len(bin_positions)}\n{fill_rate:.0f}%",
                    ha='center', va='bottom',
                    color='white',
                    bbox=dict(facecolor='red', alpha=0.7),
                    fontsize=10
                )
                annotations.append(annotation)

            fig.canvas.draw_idle()

    def on_key_press(event):
        if event.key == 'enter':
            plt.close(fig)

    fig.canvas.mpl_connect('button_press_event', onclick)
    fig.canvas.mpl_connect('key_press_event', on_key_press)
    plt.show()

    return bin_positions, fill_rates


def interactive_input_road_traffic(img, bin_positions, road_connections):
    traffic_rates = {}
    connection_keys = sorted(road_connections.keys())
    
    if not connection_keys:
        return traffic_rates
    
    fig, ax = plt.subplots(figsize=(12, 10))
    ax.imshow(img, origin='upper', aspect='equal')
    ax.set_title("点击道路段输入通畅率（按Esc键结束）")
    
    road_lines = []
    for (i, j), path in road_connections.items():
        x_vals = [p[0] for p in path]
        y_vals = [p[1] for p in path]
        line, = ax.plot(x_vals, y_vals, 'gray', alpha=0.7, linewidth=1.5)
        road_lines.append((line, (i, j)))
    
    ax.scatter([p[0] for p in bin_positions], [p[1] for p in bin_positions],
               s=150, c='red', edgecolors='black', zorder=3)
    
    for i, (x, y) in enumerate(bin_positions):
        ax.text(x, y + 15, f"{i+1}",
                ha='center', va='bottom', color='white', fontsize=10,
                bbox=dict(facecolor='red', alpha=0.7))
    
    input_count = 0
    total_connections = len(connection_keys)
    progress_text = ax.text(0.02, 0.95, f"已输入: {input_count}/{total_connections}", 
                           transform=ax.transAxes, bbox=dict(facecolor='white', alpha=0.8))
    
    road_paths = {key: path for key, path in road_connections.items()}
    
    def on_click(event):
        nonlocal input_count
        
        if event.inaxes != ax or event.button != 1:
            return
        
        x, y = event.xdata, event.ydata
        if x is None or y is None:
            return
        
        closest_key = None
        min_distance = float('inf')
        
        for key, path in road_paths.items():
            for i in range(len(path) - 1):
                x1, y1 = path[i]
                x2, y2 = path[i+1]
                distance = point_to_line_distance(x, y, x1, y1, x2, y2)
                if distance < min_distance:
                    min_distance = distance
                    closest_key = key
        
        if closest_key and closest_key not in traffic_rates:
            from_bin, to_bin = closest_key[0] + 1, closest_key[1] + 1
            traffic_rate = simpledialog.askfloat(
                f"道路通畅率输入 ({input_count+1}/{total_connections})",
                f"请输入从垃圾桶 {from_bin} 到 {to_bin} 的道路通畅率 (0.0-1.0):",
                minvalue=0.0, maxvalue=1.0, initialvalue=0.8
            )
            
            if traffic_rate is not None:
                traffic_rates[closest_key] = traffic_rate
                traffic_rates[(closest_key[1], closest_key[0])] = traffic_rate
                input_count += 1
                progress_text.set_text(f"已输入: {input_count}/{total_connections}")
                fig.canvas.draw_idle()
                
                for line, key in road_lines:
                    if key == closest_key:
                        if traffic_rate <= 0.5:
                            line.set_color('red')
                        else:
                            line.set_color('green')
                        line.set_linewidth(3.0)
    
    def on_key_press(event):
        if event.key == 'escape':
            plt.close(fig)
    
    fig.canvas.mpl_connect('button_press_event', on_click)
    fig.canvas.mpl_connect('key_press_event', on_key_press)
    
    plt.show()
    
    for key in connection_keys:
        if key not in traffic_rates:
            traffic_rates[key] = 0.8
            traffic_rates[(key[1], key[0])] = 0.8
            for line, k in road_lines:
                if k == key:
                    if 0.8 <= 0.5:
                        line.set_color('red')
                    else:
                        line.set_color('green')
                    line.set_linewidth(3.0)
    
    return traffic_rates


def point_to_line_distance(x, y, x1, y1, x2, y2):
    if x1 == x2 and y1 == y2:
        return np.hypot(x - x1, y - y1)
    
    t = max(0, min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / ((x2 - x1)**2 + (y2 - y1)** 2)))
    proj_x = x1 + t * (x2 - x1)
    proj_y = y1 + t * (y2 - y1)
    return np.hypot(x - proj_x, y - proj_y)


def detect_road_connections(img_path, bin_positions, road_threshold=127, morphology_iterations=3):
    img = cv2.imread(img_path)
    if img is None: raise ValueError("无法读取地图图像")
    
    gray_img = ensure_gray(img)
    
    outer_x_min, outer_y_min, outer_x_max, outer_y_max = 0, 0, img.shape[1] - 1, img.shape[0] - 1
    inner_x_min, inner_y_min, inner_x_max, inner_y_max = get_inner_bounds(gray_img)

    processed_img = enhance_contrast(gray_img)
    processed_img = adaptive_thresholding(processed_img, road_threshold)
    processed_img = advanced_morphology(processed_img, morphology_iterations)
    skeleton = robust_skeleton_extraction(processed_img)

    connections = {}
    n = len(bin_positions)

    for i in range(n):
        for j in range(i + 1, n):
            x1, y1 = bin_positions[i]
            x2, y2 = bin_positions[j]

            if not is_point_in_valid_area((x1, y1), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                        outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                x1, y1 = adjust_point_to_valid_area((x1, y1), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                                  outer_x_min, outer_y_min, outer_x_max, outer_y_max)
                bin_positions[i] = (x1, y1)
                
            if not is_point_in_valid_area((x2, y2), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                        outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                x2, y2 = adjust_point_to_valid_area((x2, y2), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                                  outer_x_min, outer_y_min, outer_x_max, outer_y_max)
                bin_positions[j] = (x2, y2)

            adjusted_start = adjust_to_road_distance(skeleton, (x1, y1))
            adjusted_end = adjust_to_road_distance(skeleton, (x2, y2))

            if not adjusted_start or not adjusted_end:
                path = create_smooth_path(bin_positions[i], bin_positions[j],
                                          inner_x_min=inner_x_min, inner_y_min=inner_y_min,
                                          inner_x_max=inner_x_max, inner_y_max=inner_y_max,
                                          outer_x_min=outer_x_min, outer_x_max=outer_x_max,
                                          outer_y_min=outer_y_min, outer_y_max=outer_y_max)
                connections[(i, j)] = path
                connections[(j, i)] = path[::-1]
                continue

            path = find_path_astar_4directions(skeleton, adjusted_start, adjusted_end,
                                               inner_x_min=inner_x_min, inner_y_min=inner_y_min,
                                               inner_x_max=inner_x_max, inner_y_max=inner_y_max,
                                               outer_x_min=outer_x_min, outer_x_max=outer_x_max,
                                               outer_y_min=outer_y_min, outer_y_max=outer_y_max)

            if path:
                connections[(i, j)] = path
                connections[(j, i)] = path[::-1]
            else:
                path = create_smooth_path(bin_positions[i], bin_positions[j],
                                          inner_x_min=inner_x_min, inner_y_min=inner_y_min,
                                          inner_x_max=inner_x_max, inner_y_max=inner_y_max,
                                          outer_x_min=outer_x_min, outer_x_max=outer_x_max,
                                          outer_y_min=outer_y_min, outer_y_max=outer_y_max)
                connections[(i, j)] = path
                connections[(j, i)] = path[::-1]

    return connections


def enhance_contrast(img, clip_limit=3.0, grid_size=(8, 8)):
    clahe = cv2.createCLAHE(clipLimit=clip_limit, tileGridSize=grid_size)
    return clahe.apply(img)


def adaptive_thresholding(img, threshold=127, method='otsu'):
    if method == 'otsu':
        _, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    else:
        thresh = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                       cv2.THRESH_BINARY_INV, 11, 2)
    return thresh


def advanced_morphology(img, iterations=3):
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
    img = cv2.dilate(img, kernel, iterations=1)
    img = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel, iterations=iterations)
    return img


def robust_skeleton_extraction(img):
    skeleton = cv2.ximgproc.thinning(img, thinningType=cv2.ximgproc.THINNING_ZHANGSUEN)
    kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (3, 3))
    return cv2.morphologyEx(skeleton, cv2.MORPH_OPEN, kernel)


def adjust_to_road_distance(skeleton, point, max_radius=50):
    x, y = int(point[0]), int(point[1])
    h, w = skeleton.shape
    
    inner_x_min, inner_y_min, inner_x_max, inner_y_max = get_inner_bounds(skeleton)
    outer_x_min, outer_y_min, outer_x_max, outer_y_max = 0, 0, w-1, h-1
    
    if not is_point_in_valid_area((x, y), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                outer_x_min, outer_y_min, outer_x_max, outer_y_max):
        x, y = adjust_point_to_valid_area((x, y), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                          outer_x_min, outer_y_min, outer_x_max, outer_y_max)
    
    if skeleton[y, x] == 255:
        return (x, y)
    
    dist = cv2.distanceTransform(skeleton, cv2.DIST_L2, 5)
    
    x_min = max(0, x - max_radius)
    x_max = min(w - 1, x + max_radius)
    y_min = max(0, y - max_radius)
    y_max = min(h - 1, y + max_radius)
    
    min_dist = float('inf')
    best_point = None
    for i in range(y_min, y_max + 1):
        for j in range(x_min, x_max + 1):
            if is_point_in_valid_area((j, i), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                    outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                if skeleton[i, j] == 255:
                    d = dist[i, j]
                    if d < min_dist:
                        min_dist = d
                        best_point = (j, i)
    
    return best_point


def find_path_astar_4directions(grid, start, end, max_iterations=50000,
                                inner_x_min=None, inner_y_min=None, inner_x_max=None, inner_y_max=None,
                                outer_x_min=0, outer_x_max=None, outer_y_min=0, outer_y_max=None):
    neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    start = (int(start[0]), int(start[1]))
    end = (int(end[0]), int(end[1]))
    
    if not is_point_in_valid_area(start, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                outer_x_min, outer_y_min, outer_x_max, outer_y_max):
        return None
    
    if not is_point_in_valid_area(end, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                outer_x_min, outer_y_min, outer_x_max, outer_y_max):
        return None
    
    if not (0 <= start[0] < grid.shape[1] and 0 <= start[1] < grid.shape[0] and
            0 <= end[0] < grid.shape[1] and 0 <= end[1] < grid.shape[0]):
        return None
    
    if grid[start[1], start[0]] == 0 or grid[end[1], end[0]] == 0:
        return None
    
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic_manhattan(start, end)}
    
    while open_set and max_iterations > 0:
        current = heapq.heappop(open_set)[1]
        if current == end:
            return reconstruct_path(came_from, current)
        
        max_iterations -= 1
        
        for dx, dy in neighbors:
            neighbor = (current[0]+dx, current[1]+dy)
            if 0 <= neighbor[0] < grid.shape[1] and 0 <= neighbor[1] < grid.shape[0]:
                if is_point_in_valid_area(neighbor, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                        outer_x_min, outer_y_min, outer_x_max,
                                                                                outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                    if grid[neighbor[1], neighbor[0]] == 255:
                        new_g = g_score[current] + 1
                        if neighbor not in g_score or new_g < g_score[neighbor]:
                            came_from[neighbor] = current
                            g_score[neighbor] = new_g
                            f_score[neighbor] = new_g + heuristic_manhattan(neighbor, end)
                            heapq.heappush(open_set, (f_score[neighbor], neighbor))
    
    return None


def heuristic_manhattan(a, b):
    return abs(a[0]-b[0]) + abs(a[1]-b[1])


def reconstruct_path(came_from, current):
    path = [current]
    while current in came_from:
        current = came_from[current]
        path.append(current)
    return path[::-1]


def create_smooth_path(start, end, num_points=10,
                      inner_x_min=None, inner_y_min=None, inner_x_max=None, inner_y_max=None,
                      outer_x_min=0, outer_x_max=None, outer_y_min=0, outer_y_max=None):
    x1, y1 = start
    x2, y2 = end
    
    x1, y1 = int(round(x1)), int(round(y1))
    x2, y2 = int(round(x2)), int(round(y2))
    
    if not is_point_in_valid_area((x1, y1), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                outer_x_min, outer_y_min, outer_x_max, outer_y_max):
        x1, y1 = adjust_point_to_valid_area((x1, y1), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                          outer_x_min, outer_y_min, outer_x_max, outer_y_max)
    
    if not is_point_in_valid_area((x2, y2), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                outer_x_min, outer_y_min, outer_x_max, outer_y_max):
        x2, y2 = adjust_point_to_valid_area((x2, y2), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                          outer_x_min, outer_y_min, outer_x_max, outer_y_max)
    
    path = []
    
    if (x1, y1) == (5, 2):
        if x1 > x2:
            steps_x = np.linspace(x1, x2, abs(x2 - x1) + 1, dtype=int)
            for x in steps_x:
                if is_point_in_valid_area((x, y1), inner_x_min, inner_y_min, inner_x_max, inner_y_max,
                                           outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                    path.append((x, y1))
            if y1 < y2:
                steps_y = np.linspace(y1, y2, abs(y2 - y1) + 1, dtype=int)
                last_x = path[-1][0] if path else x1
                for y in steps_y:
                    if is_point_in_valid_area((last_x, y), inner_x_min, inner_y_min, inner_x_max, inner_y_max,
                                           outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                        path.append((last_x, y))
            if x1 > x2:
                steps_x = np.linspace(path[-1][0], x2, abs(x2 - path[-1][0]) + 1, dtype=int)
                last_y = path[-1][1] if path else y1
                for x in steps_x[1:]:
                    if is_point_in_valid_area((x, last_y), inner_x_min, inner_y_min, inner_x_max, inner_y_max,
                                           outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                        path.append((x, last_y))
    elif (x1, y1) == (2, 7):
        if x1 < x2:
            steps_x = np.linspace(x1, x2, abs(x2 - x1) + 1, dtype=int)
            for x in steps_x:
                if is_point_in_valid_area((x, y1), inner_x_min, inner_y_min, inner_x_max, inner_y_max,
                                           outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                    path.append((x, y1))
            if y1 < y2:
                steps_y = np.linspace(y1, y2, abs(y2 - y1) + 1, dtype=int)
                last_x = path[-1][0] if path else x1
                for y in steps_y:
                    if is_point_in_valid_area((last_x, y), inner_x_min, inner_y_min, inner_x_max, inner_y_max,
                                           outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                        path.append((last_x, y))
    else:
        if y1 != y2:
            last_x = x1
            steps = np.linspace(y1, y2, abs(y2 - y1) + 1, dtype=int)
            for y in steps:
                if is_point_in_valid_area((last_x, y), inner_x_min, inner_y_min, inner_x_max, inner_y_max,
                                           outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                    path.append((last_x, y))
        if x1 != x2:
            last_y = path[-1][1] if path else y1
            steps = np.linspace(x1, x2, abs(x2 - x1) + 1, dtype=int)
            for x in steps[1:]:
                if is_point_in_valid_area((x, last_y), inner_x_min, inner_y_min, inner_x_max, inner_y_max,
                                           outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                    path.append((x, last_y))
    
    if len(path) < num_points:
        new_path = []
        for i in range(len(path) - 1):
            p1, p2 = path[i], path[i+1]
            interp_count = max(1, int(num_points / (len(path) - 1)))
            
            if p1[0] == p2[0]:
                ys = np.linspace(p1[1], p2[1], interp_count, dtype=int)
                for y in ys:
                    if is_point_in_valid_area((p1[0], y), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                            outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                        new_path.append((p1[0], y))
            else:
                xs = np.linspace(p1[0], p2[0], interp_count, dtype=int)
                for x in xs:
                    if is_point_in_valid_area((x, p1[1]), inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                            outer_x_min, outer_y_min, outer_x_max, outer_y_max):
                        new_path.append((x, p1[1]))
        
        if new_path:
            new_path[-1] = path[-1]
        else:
            new_path = path
        
        path = new_path
    
    return path


def get_inner_bounds(img):
    gray_img = ensure_gray(img)
    
    _, binary = cv2.threshold(gray_img, 127, 255, cv2.THRESH_BINARY_INV)
    
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    if not contours:
        h, w = gray_img.shape[:2]
        return int(w*0.2), int(h*0.2), int(w*0.8), int(h*0.8)
    
    contours = sorted(contours, key=cv2.contourArea, reverse=True)
    
    inner_contour = None
    if len(contours) > 1:
        inner_contour = contours[1]
    else:
        x, y, w, h = cv2.boundingRect(contours[0])
        inner_contour = np.array([
            [[x+w*0.1, y+h*0.1]],
            [[x+w*0.9, y+h*0.1]],
            [[x+w*0.9, y+h*0.9]],
            [[x+w*0.1, y+h*0.9]]
        ], dtype=np.int32)
    
    x, y, w, h = cv2.boundingRect(inner_contour)
    return x, y, x+w, y+h


def is_point_in_valid_area(point, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                          outer_x_min, outer_y_min, outer_x_max, outer_y_max):
    x, y = point
    if not (outer_x_min <= x <= outer_x_max and outer_y_min <= y <= outer_y_max):
        return False
    if inner_x_min is not None and inner_y_min is not None and inner_x_max is not None and inner_y_max is not None:
        return not (inner_x_min <= x <= inner_x_max and inner_y_min <= y <= inner_y_max)
    return True


def adjust_point_to_valid_area(point, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                             outer_x_min, outer_y_min, outer_x_max, outer_y_max):
    x, y = point
    
    x = max(outer_x_min, min(x, outer_x_max))
    y = max(outer_y_min, min(y, outer_y_max))
    
    if (inner_x_min is not None and inner_y_min is not None and 
        inner_x_max is not None and inner_y_max is not None and 
        inner_x_min <= x <= inner_x_max and inner_y_min <= y <= inner_y_max):
        
        distances = [
            abs(x - inner_x_min),
            abs(x - inner_x_max),
            abs(y - inner_y_min),
            abs(y - inner_y_max)
        ]
        
        min_idx = np.argmin(distances)
        if min_idx == 0:
            x = inner_x_min
        elif min_idx == 1:
            x = inner_x_max
        elif min_idx == 2:
            y = inner_y_min
        else:
            y = inner_y_max
    
    return (x, y)


def create_full_connections(bin_positions, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                           outer_x_min, outer_y_min, outer_x_max, outer_y_max):
    connections = {}
    n = len(bin_positions)
    
    for i in range(n):
        for j in range(i+1, n):
            path = create_smooth_path(bin_positions[i], bin_positions[j],
                                     inner_x_min=inner_x_min, inner_y_min=inner_y_min,
                                     inner_x_max=inner_x_max, inner_y_max=inner_y_max,
                                     outer_x_min=outer_x_min, outer_x_max=outer_x_max,
                                     outer_y_min=outer_y_min, outer_y_max=outer_y_max)
            connections[(i, j)] = path
            connections[(j, i)] = path[::-1]
    
    return connections


class PPOActor(nn.Module):
    def __init__(self, state_dim, action_dim):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(state_dim, 128),
            nn.ReLU(),
            nn.Linear(128, action_dim),
            nn.Softmax(dim=-1)
        ).to(DEVICE)
    
    def forward(self, x):
        return self.net(x.float())

class PPOCritic(nn.Module):
    def __init__(self, state_dim):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(state_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 1)
        ).to(DEVICE)
    
    def forward(self, x):
        return self.net(x.float())

class DynamicPPO:
    def __init__(self, state_dim, action_dim, lr=3e-4, gamma=0.99, eps_clip=0.2, online_interval=5):
        self.gamma = gamma
        self.eps_clip = eps_clip
        self.online_interval = online_interval
        
        self.policy = PPOActor(state_dim, action_dim)
        self.value = PPOCritic(state_dim)
        
        self.policy_optimizer = optim.Adam(self.policy.parameters(), lr=lr)
        self.value_optimizer = optim.Adam(self.value.parameters(), lr=lr)
        
        self.buffer = {k: [] for k in ['states', 'actions', 'log_probs', 'rewards', 'next_states', 'dones']}
    
    def select_action(self, state, available_actions, traffic_rates, current_node, deterministic=False):
        state = torch.tensor(state, device=DEVICE).unsqueeze(0)
        self.policy.eval()
        
        with torch.no_grad():
            probs = self.policy(state).squeeze()
        
        masked_probs = probs.clone()
        action_mask = torch.zeros_like(probs, dtype=bool)
        action_mask[available_actions] = True
        masked_probs[~action_mask] = -float('inf')
        
        if deterministic:
            action = torch.argmax(masked_probs).item()
        else:
            valid_probs = masked_probs[action_mask]
            
            traffic_boost = torch.tensor(
                [traffic_rates.get((current_node, a), 1.0) for a in available_actions],
                device=DEVICE, dtype=torch.float32
            )
            adjusted_probs = valid_probs * traffic_boost
            adjusted_probs /= adjusted_probs.sum()
            
            action_idx = torch.multinomial(adjusted_probs, 1).item()
            action = available_actions[action_idx]
        
        return action
    
    def observe(self, state, action, log_prob, reward, next_state, done):
        self.buffer['states'].append(np.array(state))
        self.buffer['actions'].append(action)
        self.buffer['log_probs'].append(log_prob)
        self.buffer['rewards'].append(reward)
        self.buffer['next_states'].append(np.array(next_state))
        self.buffer['dones'].append(done)
        
        if len(self.buffer['states']) >= self.online_interval:
            self._online_learning()
    
    def _online_learning(self):
        buffer = {k: torch.tensor(np.array(v), device=DEVICE) for k, v in self.buffer.items()}
        states, actions, old_log_probs = buffer['states'], buffer['actions'], buffer['log_probs']
        rewards, next_states, dones = buffer['rewards'], buffer['next_states'], buffer['dones']
        
        with torch.no_grad():
            values = self.value(states).squeeze()
            next_values = self.value(next_states).squeeze()
        
        returns = self._compute_returns(rewards, next_values, dones)
        advantages = (returns - values).detach()
        
        for _ in range(3):
            self.policy_optimizer.zero_grad()
            new_probs = self.policy(states).gather(1, actions.unsqueeze(1)).squeeze()
            new_log_probs = torch.log(new_probs.clamp(min=1e-8))
            ratio = torch.exp(new_log_probs - old_log_probs)
            
            surr1 = ratio * advantages
            surr2 = torch.clamp(ratio, 1-self.eps_clip, 1+self.eps_clip) * advantages
            policy_loss = -torch.min(surr1, surr2).mean()
            
            policy_loss.backward()
            self.policy_optimizer.step()
            
            self.value_optimizer.zero_grad()
            values = self.value(states).squeeze()
            value_loss = ((values - returns)**2).mean()
            
            value_loss.backward()
            self.value_optimizer.step()
        
        self.buffer = {k: [] for k in self.buffer}
    
    def _compute_returns(self, rewards, next_values, dones):
        returns = []
        R = next_values[-1]
        
        for r, nv, d in reversed(list(zip(rewards, next_values, dones))):
            d = d.float()
            R = r + self.gamma * R * (1 - d)
            returns.append(R)
        
        return torch.stack(returns[::-1])


def create_road_graph(bin_positions, road_connections, traffic_rates=None):
    n = len(bin_positions)
    adj = np.full((n, n), np.inf)
    np.fill_diagonal(adj, 0)
    
    for (i, j), path in road_connections.items():
        path_length = 0
        for k in range(len(path) - 1):
            dx = path[k+1][0] - path[k][0]
            dy = path[k+1][1] - path[k][1]
            path_length += np.hypot(dx, dy)
        
        traffic = traffic_rates.get((i, j), 1.0)
        adj[i, j] = adj[j, i] = path_length / traffic
    
    return adj


def state_to_features(state, n_bins):
    current, fills, visited = state
    return np.concatenate([
        np.eye(n_bins)[current],
        fills,
        visited.astype(float)
    ])


def dynamic_reward(
    distance_matrix, 
    current_fill, 
    next_fill, 
    current_node, 
    next_node, 
    traffic_rate,
    lambda_fill=0.4,
    lambda_traffic=0.3,
    lambda_distance=0.3
):
    real_dist = distance_matrix[current_node, next_node]
    fill_reward = next_fill * 10
    dist_penalty = -real_dist / np.max(distance_matrix)
    traffic_reward = traffic_rate * 5
    
    return (lambda_fill * fill_reward + 
            lambda_distance * dist_penalty + 
            lambda_traffic * traffic_reward)


def dynamic_path_planning(
    agent, 
    bin_positions, 
    road_connections, 
    traffic_rates,
    start_node,
    fill_rates,
    lambda_fill=0.4,
    lambda_traffic=0.3,
    lambda_distance=0.3,
    max_steps=5, 
    realtime=True
):
    n_bins = len(bin_positions)
    adj_matrix = create_road_graph(bin_positions, road_connections, traffic_rates)
    distance_matrix = dijkstra(csr_matrix(adj_matrix))
    
    path = [start_node]
    visited = np.zeros(n_bins, dtype=bool)
    visited[start_node] = True
    fills = fill_rates.copy()
    
    full_path = []
    visit_order = []
    
    steps_info = []
    
    for step in range(max_steps):
        available = np.where(~visited)[0]
        if len(available) == 0: break
        
        state = (path[-1], fills, visited.copy())
        state_feat = state_to_features(state, n_bins)
        
        action = agent.select_action(
            state_feat, available, traffic_rates, path[-1], deterministic=not realtime
        )
        next_node = action
        
        path.append(next_node)
        visited[next_node] = True
        visit_order.append(next_node)
        
        from_bin = path[-2] + 1
        to_bin = next_node + 1
        steps_info.append(f"步骤 {step+1}: 从垃圾桶 {from_bin} 到 {to_bin}")
        
        connection_key = (path[-2], path[-1])
        if connection_key in road_connections:
            segment = road_connections[connection_key]
            if full_path and segment[0] != full_path[-1]:
                full_path.append(segment[0])
            full_path.extend(segment)
        else:
            x1, y1 = bin_positions[path[-2]]
            x2, y2 = bin_positions[path[-1]]
            full_path.extend(create_smooth_path((x1, y1), (x2, y2)))
        
        current_traffic = traffic_rates.get(connection_key, 1.0)
        
        reward = dynamic_reward(
            distance_matrix,
            fills[path[-2]],
            fills[next_node],
            path[-2],
            next_node,
            current_traffic,
            lambda_fill=lambda_fill,
            lambda_traffic=lambda_traffic,
            lambda_distance=lambda_distance
        )
        
        next_fills = fills.copy()
        next_fills[next_node] = 0
        next_state = (next_node, next_fills, visited.copy())
        next_feat = state_to_features(next_state, n_bins)
        
        with torch.no_grad():
            probs = agent.policy(torch.tensor(state_feat, device=DEVICE).unsqueeze(0))
            log_prob = torch.log(probs[0, action] + 1e-8).item()
        
        agent.observe(state_feat, action, log_prob, reward, next_feat, False)
        
        fills = next_fills
    
    total_points = len(full_path)
    visit_numbers = {i: idx + 1 for idx, i in enumerate(range(total_points))}
    
    return path, full_path, visit_numbers, steps_info


def visualize_dynamic(
    bin_positions, 
    path, 
    full_path, 
    visit_numbers,
    road_connections, 
    fill_rates,
    traffic_rates,
    steps_info,
    img=None, 
    update_speed=25
):
    fig, ax = plt.subplots(figsize=(16, 10), dpi=100)
    
    if img is not None and len(img.shape) == 3:
        gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    else:
        gray_img = img
    
    ax.set_facecolor('#f0f0f0')
    
    if img is not None:
        ax.imshow(img, origin='upper', aspect='equal', alpha=0.7)
    
    for (i, j), conn_path in road_connections.items():
        traffic = traffic_rates.get((i, j), 1.0)
        if traffic <= 0.5:
            color = 'red'
        else:
            color = 'green'
        x_vals = [p[0] for p in conn_path]
        y_vals = [p[1] for p in conn_path]
        ax.plot(x_vals, y_vals, '-', alpha=0.9, linewidth=3.0, color=color)
    
    bin_scatter = ax.scatter(
        [p[0] for p in bin_positions], 
        [p[1] for p in bin_positions],
        s=150, c='red', edgecolors='black', zorder=3
    )
    
    for i, (x, y) in enumerate(bin_positions):
        ax.text(x, y + 15, f"{i+1}\n{fill_rates[i]*100:.0f}%",
                ha='center', va='bottom', color='white', fontsize=9,
                bbox=dict(facecolor='red', alpha=0.7, boxstyle='round,pad=0.3'))
    
    path_line, = ax.plot([], [], 'b-', linewidth=3, alpha=0.8, zorder=2)
    current_pos = ax.scatter([], [], s=200, c='blue', edgecolors='white', zorder=4)
    
    progress_text = ax.text(0.02, 0.95, '', transform=ax.transAxes,
                           bbox=dict(facecolor='white', alpha=0.8), fontsize=12)
    
    ax.text(0.95, 0.02, '道路通畅率图例:', transform=ax.transAxes,
           ha='right', va='bottom', fontsize=10)
    ax.text(0.95, 0.00, '红色: ≤0.5  绿色: >0.5', transform=ax.transAxes,
           ha='right', va='top', fontsize=8)
    
    steps_text = ax.text(
        0.02, 0.85, '', transform=ax.transAxes,
        bbox=dict(facecolor='white', alpha=0.8), fontsize=10,
        verticalalignment='top'
    )
    
    steps_display = "\n".join(steps_info)
    steps_text.set_text(f"路径规划步骤:\n{steps_display}")
    
    total_frames = len(full_path)
    
    def update(frame):
        if frame >= total_frames:
            progress_text.set_text("动画完成")
            return path_line, current_pos, progress_text, steps_text
        
        path_line.set_data([p[0] for p in full_path[:frame+1]], 
                          [p[1] for p in full_path[:frame+1]])
        
        current_pos.set_offsets([full_path[frame]])
        
        progress_text.set_text(f'进度: {frame+1}/{total_frames} 点')
        
        return path_line, current_pos, progress_text, steps_text
    
    animation = FuncAnimation(
        fig, update, frames=total_frames, interval=update_speed,
        blit=True, repeat=False
    )
    
    ax.set_title('考虑道路通畅率的智能垃圾桶路径规划', fontsize=16)
    plt.tight_layout()
    plt.show()
    
    return animation


def check_full_path(full_path, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                    outer_x_min, outer_y_min, outer_x_max, outer_y_max):
    for point in full_path:
        if not is_point_in_valid_area(point, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                      outer_x_min, outer_y_min, outer_x_max, outer_y_max):
            raise ValueError(f"路径点 {point} 不在有效区域内")


def main():
    print("===== 智能垃圾桶路径规划系统 =====")
    
    root = tk.Tk()
    root.withdraw()
    print("请选择地图图像文件...")
    img_path = filedialog.askopenfilename(
        title="选择地图图像",
        filetypes=[("图像文件", "*.png;*.jpg;*.jpeg;*.bmp")]
    )
    if not img_path:
        print("未选择图像，程序退出")
        return
    
    try:
        img = cv2.imread(img_path)
        if img is None:
            raise ValueError("无法读取地图图像")
        print(f"成功加载地图: {img_path}")
    except Exception as e:
        print(f"加载地图失败: {e}")
        return
    
    print("请在地图上点击选择垃圾桶位置，并输入填充率")
    bin_positions, fill_rates = show_map_with_annotations(img_path)
    
    if not bin_positions:
        print("未选择任何垃圾桶位置，程序退出")
        return
    
    print(f"已选择 {len(bin_positions)} 个垃圾桶位置")
    
    print("正在检测道路连接...")
    try:
        road_connections = detect_road_connections(img_path, bin_positions)
    except Exception as e:
        print(f"道路连接检测失败: {e}")
        print("使用全连接网络替代")
        gray_img = ensure_gray(img)
        inner_x_min, inner_y_min, inner_x_max, inner_y_max = get_inner_bounds(gray_img)
        outer_x_min, outer_y_min, outer_x_max, outer_y_max = 0, 0, img.shape[1] - 1, img.shape[0] - 1
        road_connections = create_full_connections(bin_positions, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                                                  outer_x_min, outer_y_min, outer_x_max, outer_y_max)
    
    print("请在地图上点击道路段输入通畅率（按Esc键结束）")
    traffic_rates = interactive_input_road_traffic(img, bin_positions, road_connections)
    
    n_bins = len(bin_positions)
    state_dim = n_bins + n_bins + n_bins
    action_dim = n_bins
    agent = DynamicPPO(state_dim, action_dim)
    
    start_node = simpledialog.askinteger(
        "起点选择",
        f"请选择起点垃圾桶编号 (1-{n_bins}):",
        minvalue=1, maxvalue=n_bins
    )
    if start_node is None:
        start_node = 0
    else:
        start_node -= 1
    
    lambda_fill = simpledialog.askfloat(
        "权重设置",
        "请输入填充率权重 (0.0-1.0):",
        minvalue=0.0, maxvalue=1.0, initialvalue=0.4
    )
    lambda_traffic = simpledialog.askfloat(
        "权重设置",
        "请输入道路通畅率权重 (0.0-1.0):",
        minvalue=0.0, maxvalue=1.0, initialvalue=0.3
    )
    lambda_distance = 1.0 - lambda_fill - lambda_traffic
    
    if lambda_fill is None or lambda_traffic is None:
        lambda_fill, lambda_traffic, lambda_distance = 0.4, 0.3, 0.3
    
    print("正在执行动态路径规划...")
    try:
        path, full_path, visit_numbers, steps_info = dynamic_path_planning(
            agent, bin_positions, road_connections, traffic_rates, start_node, fill_rates,
            lambda_fill=lambda_fill, lambda_traffic=lambda_traffic, lambda_distance=lambda_distance
        )
        
        gray_img = ensure_gray(img)
        inner_x_min, inner_y_min, inner_x_max, inner_y_max = get_inner_bounds(gray_img)
        outer_x_min, outer_y_min, outer_x_max, outer_y_max = 0, 0, img.shape[1] - 1, img.shape[0] - 1
        check_full_path(full_path, inner_x_min, inner_y_min, inner_x_max, inner_y_max, 
                       outer_x_min, outer_y_min, outer_x_max, outer_y_max)
        
        print(f"路径规划完成，总路径长度: {len(full_path)} 个点")
        print(f"访问顺序: {[i+1 for i in path]}")
        
        print("正在可视化路径...")
        visualize_dynamic(
            bin_positions, path, full_path, visit_numbers, road_connections, fill_rates, traffic_rates, steps_info, img=img
        )
        
        print("路径规划系统运行完毕！")
        
    except Exception as e:
        print(f"路径规划失败: {e}")
        return


if __name__ == "__main__":
    main()